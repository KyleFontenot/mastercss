## Overview [sr-only]
A style can be composed of multiple syntaxes, you can provide an abstract name for this set of classes and reuse it anywhere.
```html
<button class="btn btn-primary">Submit</button>
```
As the styles grow, the class name combinations and the same design patterns appear over and over again in the code. To improve development efficiency and maintain design consistency, you should reuse or access them in some way.

This guide also provides specialized solutions tailored for frameworks.

---

## Creating abstract styles
Traditionally, we define styles like `.btn` or `.card` by writing CSS rules. In Master CSS, we abstract them using [styles](/guide/custom-styles), which is similar to [Figma's Styles](https://help.figma.com/hc/en-us/articles/360039238753-Styles-in-Figma).

The UI is composed of 1 to 4:

1. [Variables](/guide/using-variables) / [Animations](/guide/custom-animations) / [Functions](/reference/custom-syntax#functions) / [Selectors](/reference/custom-syntax#selectors) / [At](/reference/custom-syntax#at-rules) / [Utilities](/reference/utilities)
1. [Syntaxes](/guide/custom-syntax#syntaxes)
1. [Styles](/guide/custom-styles)
1. [Components](#componentization)

### Add a style
Create an abstract style using Master CSS syntax.
<Overview />
Master CSS shares the same CSS declarations for `css .inline-flex, .btn { ... }` through a selector list. This structural arrangement enhances browser rendering and enables selectors or media queries to be applied within the `config.styles`.

### Add a style with states
Create an abstract style with [state selectors](/guide/state-selectors) and [applying conditionally](/guide/applying-conditionally).
<Code lang="js" name="master.css.js">{require('!!raw-loader!./tests/add-a-style-with-states/master.css.js').default}</Code>
(click) Try clicking the button to see the outline effect
<Demo>
    <button className="center-content inline-flex bg:invert fg:invert font:14 font:medium h:10x px:4x r:2x outline:2|invert:focus outline-offset:2:focus">Submit</button>
</Demo>
<Code lang="html">{require('!!raw-loader!./tests/add-a-style-with-states/template.html').default}</Code>
<details>
    <summary>Generated CSS</summary>
    <div>
        <Code lang="css" beautify>{require('!!raw-loader!./tests/add-a-style-with-states/generated.css').default}</Code>
    </div>
</details>

### Add styles in a nested structure
Create and manage a set of abstract styles in a nested structure. Rather than repeating the same style names over and over again, you can write one style inside another. Master CSS will automatically combine the outer style‚Äôs name with the inner style‚Äôs.
<Code lang="js" name="master.css.js">{require('!!raw-loader!./tests/add-styles-in-a-nested-structure/master.css.js').default}</Code>
Apply the styles:
<Code lang="html">{require('!!raw-loader!./tests/add-styles-in-a-nested-structure/template.html').default}</Code>
<details>
    <summary>Generated CSS</summary>
    <div>
        <Code lang="css" beautify>{require('!!raw-loader!./tests/add-styles-in-a-nested-structure/generated.css').default}</Code>
    </div>
</details>
The empty string `''` represents an outer style, much like Sass's `&`.

### Extend an existing style
Create a new abstract style by extending an existing style and adding additional syntax.
<Code lang="js" name="master.css.js">{require('!!raw-loader!./tests/extend-an-existing-style/master.css.js').default}</Code>
You can see that `b` inherits the text lime color of `a`:
<Demo $py={0}>
    <DemoPanel>
        <span className="font:20 fg:lime">a</span>
        <span className="font:20 fg:lime text:underline">b</span>
    </DemoPanel>
</Demo>
<Code lang="html">{require('!!raw-loader!./tests/extend-an-existing-style/template.html').default}</Code>
<details>
    <summary>Generated CSS</summary>
    <div>
        <Code lang="css" beautify>{require('!!raw-loader!./tests/extend-an-existing-style/generated.css').default}</Code>
    </div>
</details>

---

## Managing styles
As usual, you can split the styles into multiple files for management. When the project is small in scale, you don't necessarily have to insist on splitting style files.
```treeview
üóÇÔ∏è styles
|-- üìÑ button.ts
`-- üìÑ card.ts
üìÑ master.css.ts
```

### Create button styles
Let's implement a rich button.
<Code lang="ts" name="styles/button.ts">
    {require('!!raw-loader!~/site/styles/btn').default}
</Code>
[Extend](/reference/configuration#extends) them uniformly in the __master.css.ts__ entry file.
```js name=master.css.ts
import type { Config } from '@master/css'
import button from './styles/button'

export default {
    extends: [
        button
    ]
} as Config
```

To apply the button sizes.
<Demo className="gap:8x">
    <button className="btn btn-xs yellow touch-yellow">Submit</button>
    <button className="btn btn-sm yellow touch-yellow">Submit</button>
    <button className="btn btn-md yellow touch-yellow">Submit</button>
    <button className="btn btn-lg yellow touch-yellow">Submit</button>
    <button className="btn btn-xl yellow touch-yellow">Submit</button>
</Demo>
```html
<button class="btn **btn-xs** ‚Ä¶">Submit</button>
<button class="btn **btn-sm** ‚Ä¶">Submit</button>
<button class="btn **btn-md** ‚Ä¶">Submit</button>
<button class="btn **btn-lg** ‚Ä¶">Submit</button>
<button class="btn **btn-xl** ‚Ä¶">Submit</button>
```
To apply the button sizes that are finely tuned for rounded styles.
<Demo className="gap:8x">
    <button className="btn btn-xs rounded! yellow touch-yellow">Submit</button>
    <button className="btn btn-sm rounded! yellow touch-yellow">Submit</button>
    <button className="btn btn-md rounded! yellow touch-yellow">Submit</button>
    <button className="btn btn-lg rounded! yellow touch-yellow">Submit</button>
    <button className="btn btn-xl rounded! yellow touch-yellow">Submit</button>
</Demo>
```html
<button class="btn btn-xs **rounded** ‚Ä¶">Submit</button>
<button class="btn btn-sm **rounded** ‚Ä¶">Submit</button>
<button class="btn btn-md **rounded** ‚Ä¶">Submit</button>
<button class="btn btn-lg **rounded** ‚Ä¶">Submit</button>
<button class="btn btn-xl **rounded** ‚Ä¶">Submit</button>
```
To design a scalable style, you should ensure the single responsibility of class composition; otherwise, you may end up using a lot of `!important` to override rules or the `@preset` layer to lower default styles, ultimately leading to chaotic styles.

### Create common variables and styles
We define [variables and modes](/guide/variables-and-modes) to create tokens supporting light/dark modes in advance. This not only simplifies template markup but also reduces CSS rule output.
<Code lang="ts" name="master.css.ts">
    {require('!!raw-loader!~/site/styles/base').default}
</Code>
- Variables
    - `yellow-ring` is an outline color that complements a yellow background.
    - `touch-yellow` is a background color on hover.
    - `text-yellow-contrast` is a contrasting color fine-tuned against a yellow background.
- Styles
    - `.yellow` sets a background, foreground and outline style for a yellow theme.
    - `.yellow-touch` sets a background, foreground and outline style for a yellow theme interaction.

<Demo className="gap:8x">
    <button className="btn btn-md yellow touch-yellow">Submit</button>
</Demo>
```html
<button class="btn btn-md **yellow** **touch-yellow**">Submit</button>
```

---

## Componentization
In addition to [styles](#abstract-styles), we provide a CSS-in-JS style utility, [Master Styled](https://github.com/master-co/styled), to help you create a component with classes in one line. It supports Vanilla js, React, and Vue.

```treeview
üóÇÔ∏è components
|-- üìÑ Button.tsx
`-- üìÑ Card.tsx
üìÑ master.css.ts
```

### Create a button component
You can define type-safe styles and corresponding classes for style properties.
```tsx name=components/Button.tsx
import styled from '@master/styled.react'

const sizes = {
    xs: 'font:12 h:6x ‚Ä¶',
    sm: 'font:12 h:8x ‚Ä¶',
    md: 'font:14 h:10x ‚Ä¶',
    lg: 'font:16 h:12x ‚Ä¶',
    xl: 'font:16 h:14x  ‚Ä¶'
}

declare type Props = {
    $size: keyof typeof sizes
    disabled?: boolean
}

const Button = styled.button<Props>('inline-flex font:semibold', {
    $size: sizes,
    disabled: 'opacity:.5'
})

Button.defaultProps = {
    $size: 'md'
}

export default Button
```
To use the button component.
```tsx
<Button $size="sm" disabled>Submit</Button>
```
Rendered as:
```html
<button class="inline-flex font:semibold font:12 h:8x ‚Ä¶ opacity:.5">Submit</button>
```
However, if the component involves richer implementations such as `loading`, you should wrap it with a functional component.

### Create a block-scoped component
`styled` operates on an element basis, unlike global [styles](#abstract-styles) mentioned above, and you can declare it within a functional component or at the top level.

(i) Create a reusable section component specific to a marketing page.
```tsx name=page.tsx
import styled from '@master/styled.react'

export default function Page() {
    const Section = styled.section`bg:slate-90 text:white p:15x|20x`
    return (
        <>
-           <section className="bg:slate-90 text:white p:15x|20x">...</section>
-           <section className="bg:slate-90 text:white p:15x|20x">...</section>
+           <Section>...</Section>
+           <Section>...</Section>
            ...
        </>
    )
}
```
This is useful for block-specific style reuse, rather than creating `styles['home-section']` which may pollute global styles or cause name collisions.

---

## Summary

- Moderately abstracting styles make design easier to manage and maintain consistency, but it doesn't mean that all styles should be abstracted.
- Only abstract styles that have the potential for reuse, rather than naming them simply for brevity or naming's sake.
- A good CSS structure combines abstract classes and utility classes ‚Äî don‚Äôt get hung up on specific approaches.